
本地部署测试

1. **一个 Azure 账户**：如果你没有，可以注册一个免费账户。
2. **一个 YugabyteDB 实例**：
    - 最简单的方式是使用 [YugabyteDB Managed](https://cloud.yugabyte.com/) 的免费集群。注册后几分钟内就能创建一个。
    - 或者你在本地用 Docker 运行了一个 YugabyteDB 实例。
3. **开发工具**：
    - 安装 [Visual Studio Code](https://code.visualstudio.com/)。
    - 在 VS Code 中安装 **Azure Functions** 扩展。
    - 安装 [Python](https://www.python.org/) (建议 3.8 或更高版本)。
    - 安装 [Azure Functions Core Tools](https://docs.microsoft.com/azure/azure-functions/functions-run-local)。

## 在本地Docker如何部署一个YubabyteDB
好的，在本地使用 Docker 部署 YugabyteDB 是一个非常方便快捷的方法，可以让你快速搭建一个用于开发和测试的环境。

下面我将介绍两种最常用的方法：

1.  **部署单节点集群**：最快、最简单的方式，适合入门和基本功能测试。
2.  **使用 Docker Compose 部署多节点集群**：模拟一个更真实的分布式环境，适合测试高可用和扩展性。

---

### 方法一：部署单节点 YugabyteDB 集群（最快入门）

这个方法会创建一个包含所有组件（Master 和 T-Server）的单节点 YugabyteDB 集群。

#### 前提条件
- 已安装并运行 Docker Desktop (Windows/Mac) 或 Docker Engine (Linux)。

#### 步骤

1.  **拉取并运行 YugabyteDB 容器**
    打开你的终端（PowerShell、CMD 或其他 Shell），运行以下命令：

    ```bash
    docker run -d --name yugabyte \
        -p 7000:7000 \
        -p 9000:9000 \
        -p 5433:5433 \
        -p 9042:9042 \
        yugabytedb/yugabyte:latest \
        bin/yugabyted start --daemon=false --ui=true
    ```

```
docker pull yugabytedb/yugabyte:latest
docker run -d --name yugabyte \
 -p 7000:7000 -p 9000:9000 -p 5433:5433 yugabytedb/yugabyte:latest \
 bin/yugabyted start --daemon=false
```

2.  **命令解析**
    - `docker run -d`: 在后台（detached mode）运行容器。
    - `--name yugabyte`: 为容器指定一个方便记忆的名称 `yugabyte`。
    - `-p 7000:7000`: 映射 **Master** 的 Web UI 端口。你可以通过 `http://localhost:7000` 访问。
    - `-p 9000:9000`: 映射 **T-Server** 的 Web UI 端口。
    - `-p 5433:5433`: 映射 **YSQL** API 的端口，这是兼容 **PostgreSQL** 的接口。
    - `-p 9042:9042`: 映射 **YCQL** API 的端口，这是兼容 **Cassandra** 的接口。
    - `yugabytedb/yugabyte:latest`: 指定要使用的 Docker 镜像。
    - `bin/yugabyted start --daemon=false --ui=true`: 在容器内启动 YugabyteDB 的命令。`--daemon=false` 确保进程在前台运行，这是 Docker 容器的要求。

3.  **验证部署**
    - **检查容器状态**:
      ```bash
      docker ps
      ```
      你应该能看到名为 `yugabyte` 的容器正在运行 (Up)。

    - **访问 Web UI**:
      在浏览器中打开 `http://localhost:7000`。你应该能看到 YugabyteDB 的管理控制台，其中显示有一个 Master 和一个 T-Server 正在运行。

    - **连接数据库 (YSQL/PostgreSQL)**:
      你可以使用 `docker exec` 命令进入容器并连接到 YSQL shell。
      ```bash
      docker exec -it yugabyte bin/ysqlsh
      ```
      连接成功后，你会看到类似 `yugabyte=#` 的提示符。现在你可以像使用 PostgreSQL 一样执行 SQL 命令了，例如：
      ```sql
      -- 查看所有数据库
      \l
      
      -- 创建一个新表
      CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(50));
      
      -- 插入数据
      INSERT INTO employees VALUES (1, 'John Doe');
      
      -- 查询数据
      SELECT * FROM employees;
      
      -- 退出
      \q
      ```

4.  **停止和清理**
    - **停止容器**（数据会保留）：
      ```bash
      docker stop yugabyte
      ```
    - **重新启动容器**：
      ```bash
      docker start yugabyte
      ```
    - **停止并彻底删除容器**（数据会丢失）：
      ```bash
      docker rm -f yugabyte
      ```

---

### 方法二：使用 Docker Compose 部署多节点本地集群

这个方法使用 `docker-compose` 来创建一个包含1个 Master 和3个 T-Server 的集群，能更好地模拟真实的分布式环境。

#### 前提条件
- 已安装 Docker 和 `docker-compose`。

#### 步骤

1.  **创建 `docker-compose.yml` 文件**
    在一个新的空文件夹中，创建一个名为 `docker-compose.yml` 的文件，并将以下内容复制进去：

    ```yaml
    version: '3.8'
    
    services:
      yb-master:
        image: yugabytedb/yugabyte:latest
        container_name: yb-master-n1
        command: >
          bin/yb-master
            --fs_data_dirs "/mnt/data"
            --master_addresses yb-master-n1:7100
            --rpc_bind_addresses yb-master-n1:7100
            --enable_ysql
        ports:
          - "7000:7000"
    
      yb-tserver-n1:
        image: yugabytedb/yugabyte:latest
        container_name: yb-tserver-n1
        command: >
          bin/yb-tserver
            --fs_data_dirs "/mnt/data"
            --tserver_master_addrs yb-master-n1:7100
            --rpc_bind_addresses yb-tserver-n1:9100
        ports:
          - "9042:9042"  # YCQL
          - "5433:5433"  # YSQL
          - "9000:9000"  # T-Server Web UI
        depends_on:
          - yb-master
    
      yb-tserver-n2:
        image: yugabytedb/yugabyte:latest
        container_name: yb-tserver-n2
        command: >
          bin/yb-tserver
            --fs_data_dirs "/mnt/data"
            --tserver_master_addrs yb-master-n1:7100
            --rpc_bind_addresses yb-tserver-n2:9100
        depends_on:
          - yb-master
    
      yb-tserver-n3:
        image: yugabytedb/yugabyte:latest
        container_name: yb-tserver-n3
        command: >
          bin/yb-tserver
            --fs_data_dirs "/mnt/data"
            --tserver_master_addrs yb-master-n1:7100
            --rpc_bind_addresses yb-tserver-n3:9100
        depends_on:
          - yb-master
    ```

2.  **启动集群**
    在包含 `docker-compose.yml` 文件的目录中，运行以下命令：
    ```bash
    docker-compose up -d
    ```
    Docker Compose 会自动拉取镜像并按顺序创建和启动4个容器。

3.  **验证部署**
    - **检查容器状态**:
      ```bash
      docker-compose ps
      ```
      你应该能看到 `yb-master-n1`, `yb-tserver-n1`, `yb-tserver-n2`, `yb-tserver-n3` 都在运行。

    - **访问 Web UI**:
      在浏览器中打开 `http://localhost:7000`。在 "Tablet Servers" 页面，你应该能看到3个 T-Server 节点都已成功注册。

    - **连接数据库**:
      连接方式和单节点一样，因为我们已经将 `yb-tserver-n1` 的 YSQL 端口 `5433` 映射到了本地。
      ```bash
      docker exec -it yb-tserver-n1 bin/ysqlsh
      ```
      或者，你可以使用任何本地的 PostgreSQL 客户端（如 DBeaver, pgAdmin）连接到 `localhost:5433`。

4.  **停止和清理**
    - **停止并删除所有容器和网络**：
      在 `docker-compose.yml` 文件所在的目录中运行：
      ```bash
      docker-compose down
      ```
      这条命令会清理所有由 `docker-compose up` 创建的资源。

### 总结

-   对于**初学者和快速开发**，**方法一（单节点）** 是最佳选择，简单、快速、资源占用少。
-   如果你需要测试 YugabyteDB 的**分布式特性**（如高可用性、数据复制或横向扩展），建议使用**方法二（Docker Compose 多节点集群）**。




## yugabyte

### 方式一：使用内置命令行工具 `ysqlsh` (推荐初学者)

这是与 YugabyteDB 的 YSQL (PostgreSQL 兼容) API 交互的最直接方式。你将进入容器内部，使用它的命令行客户端。

1. **打开你的终端** (PowerShell, CMD, 或 WSL Shell)。
2. **执行以下命令进入容器并启动 `ysqlsh`**：

```
docker exec -it yugabyte bin/ysqlsh
```

- `docker exec`: 在一个正在运行的容器中执行命令。
- `-it`: 分配一个交互式终端。
- `yugabyte`: 你之前为容器取的名字。
- `bin/ysqlsh`: 要在容器内运行的程序。


1. **成功连接！**  
    如果一切顺利，你会看到类似 `yugabyte=#` 的提示符。这表示你已经成功连接到 YSQL 数据库了！
2. **现在，让我们来执行一些基本的 SQL 操作**：  
    你可以像操作 PostgreSQL 一样操作它。复制并粘贴以下命令，逐行执行：

```sql
-- 1. 创建一个新的数据库
CREATE DATABASE my_first_db;

-- 2. 连接到你刚创建的数据库
\c my_first_db;

-- 3. 创建一个简单的表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10, 2)
);

-- 4. 插入一些数据
INSERT INTO employees (id, name, department, salary) VALUES
(1, 'Alice', 'Engineering', 90000.00),
(2, 'Bob', 'Marketing', 75000.00),
(3, 'Charlie', 'Engineering', 95000.00);

-- 5. 查询所有数据
SELECT * FROM employees;

-- 6. 查询工程部门的员工
SELECT name, salary FROM employees WHERE department = 'Engineering';

-- 7. 退出 ysqlsh
\q
```

执行 `\q` 后，你将退回到你原来的终端。


### 连接失败

![[Pasted image 20251126122504.png]]

```
sudo docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' yugabyte
 # 假设获取到的 IP 是 172.17.0.2
docker exec -it yugabyte bin/ysqlsh --host 172.17.0.2

```

----------------------------

## 251126

创建数据库

```
-- 创建数据库
CREATE DATABASE event_db;

-- 使用数据库
\c event_db;

-- 创建 通知历史表 (notification_history)
CREATE TABLE notification_history (
    notification_id UUID PRIMARY KEY,
    apikey varchar NOT NULL,
    request_result jsonb NOT NULL,
    confirmation_result jsonb,
    status varchar NOT NULL,
    upsert_date TIMESTAMP
);

-- 创建 事件数据表 (event_data)
CREATE TABLE event_data (
    event_id UUID PRIMARY KEY,
    dealer_code varchar NOT NULL,
    employee_code varchar NOT NULL,
    apikey varchar NOT NULL,
    management_information jsonb,
    information jsonb,
    upsert_date TIMESTAMP
);


-- 插入数据到 notification_history 表
-- 插入一条“未完成”的记录
INSERT INTO notification_history (notification_id, request_result, status)
VALUES (
    gen_random_uuid(),
    '{"url": "https://api.example.com/notify", "payload": {"message": "New event occurred"}}',
    'Unfinished'
);

-- 插入一条“已完成”的记录
INSERT INTO notification_history (notification_id, request_result, confirmation_result, status)
VALUES (
    gen_random_uuid(),
    '{"url": "https://api.example.com/notify", "payload": {"message": "Old event processed"}}',
    '{"response_code": 200, "body": "OK"}',
    'Finished'
);


-- 插入数据到 event_data 表
INSERT INTO event_data (event_id, dealer_code, employee_code, apikey, management_information, information, upsert_date)
VALUES (
    gen_random_uuid(),
    'DLR-001',
    'EMP-12345',
    'xyz-abc-123-456',
    '{"source": "web_portal", "user": "admin"}',
    '{"customer_id": "CUST-987", "action": "login"}',
    NOW()
);

INSERT INTO event_data (event_id, dealer_code, employee_code, apikey, information, upsert_date)
VALUES (
    gen_random_uuid(),
    'DLR-002',
    'EMP-67890',
    'pqr-stu-789-012',
    '{"customer_id": "CUST-654", "action": "purchase", "item_id": "ITEM-A"}',
    NOW()
);


-- 验证数据是否成功插入表中
SELECT * FROM notification_history;
SELECT * FROM event_data;


```